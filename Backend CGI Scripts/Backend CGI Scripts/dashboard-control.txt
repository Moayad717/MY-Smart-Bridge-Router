#!/bin/sh

# Set content type to plain text
echo "Content-type: text/plain"
echo ""

# Check action parameter
ACTION=$(echo "$QUERY_STRING" | grep -oE 'action=([^&]+)' | cut -d= -f2)

# Status file location
STATUS_FILE="/tmp/speedtest_status.txt"
RESULT_FILE="/tmp/speedtest_result.txt"

case "$ACTION" in
    "start")
        # Start a new speedtest if one isn't already running
        if [ -f "$STATUS_FILE" ] && grep -q "running" "$STATUS_FILE"; then
            echo "A speedtest is already running. Please wait..."
        else
            echo "Starting speedtest in background..."
            echo "running" > "$STATUS_FILE"

            # Run speedtest in background and save result
            {
                echo "Router: $(uname -n)" > "$RESULT_FILE"
                echo "Started: $(date)" >> "$RESULT_FILE"
                echo "" >> "$RESULT_FILE"

                # Run speedtest and format output consistently for easier parsing
                if output=$(speedtest-cli --simple 2>&1); then
                    # Make sure output format is consistent to match JavaScript parser
                    echo "$output" | grep -i "ping" | sed 's/ \+/ /g' >> "$RESULT_FILE"
                    echo "$output" | grep -i "download" | sed 's/ \+/ /g' >> "$RESULT_FILE"
                    echo "$output" | grep -i "upload" | sed 's/ \+/ /g' >> "$RESULT_FILE"
                else
                    echo "Error: Speedtest failed" >> "$RESULT_FILE"
                    echo "$output" >> "$RESULT_FILE"
                    # Add empty results to prevent parsing errors
                    echo "Ping: 0 ms" >> "$RESULT_FILE"
                    echo "Download: 0 Mbit/s" >> "$RESULT_FILE"
                    echo "Upload: 0 Mbit/s" >> "$RESULT_FILE"
                fi

                echo "" >> "$RESULT_FILE"
                echo "Test completed at $(date)" >> "$RESULT_FILE"

                # Update status file
                echo "completed" > "$STATUS_FILE"
            } &

            echo "Speedtest started in background."
        fi
        ;;

    "status")
        # Check if speedtest status file exists
        if [ -f "$STATUS_FILE" ]; then
            STATUS=$(cat "$STATUS_FILE")
            echo "$STATUS"
        else
            echo "No speedtest has been run yet."
        fi
        ;;

    "results")
        # Display speedtest results if available
        if [ -f "$RESULT_FILE" ]; then
            cat "$RESULT_FILE"
        else
            echo "No speedtest results available."
            # Add empty results to prevent parsing errors
            echo "Ping: 0 ms"
            echo "Download: 0 Mbit/s"
            echo "Upload: 0 Mbit/s"
        fi
        ;;

    "reboot")
        # Log the reboot request
        logger -t dashboard-control "Reboot initiated from web dashboard"

        # Respond to client before rebooting
        echo "Router reboot initiated. Your router will be unavailable for approximately 1 minute."
        echo "Wait until the router reboots before trying to reconnect."

        # Schedule reboot to happen after response is sent (5 seconds delay)
        {
            sleep 5
            reboot
        } &
        ;;

    "router-status")
        # Return basic system information
        uptime=$(cat /proc/uptime | awk '{print $1}')
        uptime_days=$(echo $uptime | awk '{print int($1/86400)}')
        uptime_hours=$(echo $uptime | awk '{print int(($1%86400)/3600)}')
        uptime_minutes=$(echo $uptime | awk '{print int(($1%3600)/60)}')

        echo "Router: $(uname -n)"
        echo "Uptime: ${uptime_days}d ${uptime_hours}h ${uptime_minutes}m"
        echo "Load: $(cat /proc/loadavg | cut -d ' ' -f 1-3)"
        echo "Memory used: $(free | grep Mem | awk '{print int($3/$2 * 100)}')%"
        ;;

    "system-stats")
        # Get CPU temperature
        if [ -f /sys/class/thermal/thermal_zone0/temp ]; then
            temp=$(awk '{printf "%.1f", $1/1000}' /sys/class/thermal/thermal_zone0/temp)
            echo "CPU_Temperature: $temp°C"
        elif [ -e /sys/devices/virtual/thermal/thermal_zone0/temp ]; then
            temp=$(awk '{printf "%.1f", $1/1000}' /sys/devices/virtual/thermal/thermal_zone0/temp)
            echo "CPU_Temperature: $temp°C"
        elif [ -e /sys/class/hwmon/hwmon0/temp1_input ]; then
            temp=$(awk '{printf "%.1f", $1/1000}' /sys/class/hwmon/hwmon0/temp1_input)
            echo "CPU_Temperature: $temp°C"
        elif command -v ubus >/dev/null && ubus call system board 2>/dev/null | grep -q temperature; then
            temp=$(ubus call system board | jsonfilter -e '@.temperature' | awk '{printf "%.1f", $1}')
            echo "CPU_Temperature: $temp°C"
        else
            echo "CPU_Temperature: N/A"
        fi

        # Get system load (1, 5, 15 min averages)
        load_avg=$(cat /proc/loadavg)
        load_1min=$(echo $load_avg | awk '{print $1}')
        load_5min=$(echo $load_avg | awk '{print $2}')
        load_15min=$(echo $load_avg | awk '{print $3}')
        echo "Load_1min: $load_1min"
        echo "Load_5min: $load_5min"
        echo "Load_15min: $load_15min"

        # Get CPU usage per core
        if [ -e /proc/stat ]; then
            # Get number of CPU cores
            num_cores=$(grep -c ^processor /proc/cpuinfo)

            # Get current CPU stats
            for i in $(seq 0 $(($num_cores - 1))); do
                cpu_line=$(grep "^cpu$i " /proc/stat)
                user=$(echo $cpu_line | awk '{print $2}')
                nice=$(echo $cpu_line | awk '{print $3}')
                system=$(echo $cpu_line | awk '{print $4}')
                idle=$(echo $cpu_line | awk '{print $5}')
                iowait=$(echo $cpu_line | awk '{print $6}')
                irq=$(echo $cpu_line | awk '{print $7}')
                softirq=$(echo $cpu_line | awk '{print $8}')

                # Calculate total and idle
                total=$((user + nice + system + idle + iowait + irq + softirq))

                # Store values for future calculation
                echo "$total $idle" > "/tmp/cpu_stats_$i"

                # If we have previous measurements, calculate usage
                if [ -e "/tmp/cpu_stats_prev_$i" ]; then
                    prev_vals=$(cat "/tmp/cpu_stats_prev_$i")
                    prev_total=$(echo $prev_vals | awk '{print $1}')
                    prev_idle=$(echo $prev_vals | awk '{print $2}')

                    # Calculate CPU usage
                    total_diff=$((total - prev_total))
                    idle_diff=$((idle - prev_idle))

                    if [ $total_diff -gt 0 ]; then
                        usage=$(awk "BEGIN {printf \"%.1f\", (1 - $idle_diff / $total_diff) * 100}")
                        echo "CPU${i}_Usage: $usage%"
                    else
                        echo "CPU${i}_Usage: 0.0%"
                    fi
                else
                    echo "CPU${i}_Usage: calculating..."
                fi

                # Save current values for next calculation
                mv "/tmp/cpu_stats_$i" "/tmp/cpu_stats_prev_$i"
            done
        else
            echo "CPU_Usage: N/A"
        fi

        # Get memory usage
        if [ -e /proc/meminfo ]; then
            mem_total=$(grep MemTotal /proc/meminfo | awk '{print $2}')
            mem_free=$(grep MemFree /proc/meminfo | awk '{print $2}')
            mem_buffers=$(grep Buffers /proc/meminfo | awk '{print $2}')
            mem_cached=$(grep -w "^Cached" /proc/meminfo | awk '{print $2}')

            mem_used=$((mem_total - mem_free - mem_buffers - mem_cached))
            mem_percent=$(awk "BEGIN {printf \"%.1f\", ($mem_used / $mem_total) * 100}")

            echo "Memory_Total: $(awk "BEGIN {printf \"%.2f\", $mem_total/1024}")MB"
            echo "Memory_Used: $(awk "BEGIN {printf \"%.2f\", $mem_used/1024}")MB"
            echo "Memory_Percent: $mem_percent%"
        else
            echo "Memory_Usage: N/A"
        fi

        # Get collectd thermal data if available
        if [ -d /var/lib/collectd/rrd ]; then
            # Try to find thermal plugin data
            thermal_rrd=$(find /var/lib/collectd/rrd -name "thermal-*.rrd" | head -1)
            if [ -n "$thermal_rrd" ]; then
                # Check if rrdtool is installed
                if command -v rrdtool >/dev/null; then
                    # Extract last temperature value
                    rrd_data=$(rrdtool lastupdate "$thermal_rrd")
                    rrd_temp=$(echo "$rrd_data" | tail -1 | awk '{print $2}')
                    echo "Collectd_Thermal: $rrd_temp°C"
                fi
            fi
        fi
        ;;

    *)
        # Default - show help
        echo "Dashboard Control CGI Script"
        echo "==========================="
        echo ""
        echo "Available actions:"
        echo "  start        - Start a new speedtest in background"
        echo "  status       - Check if a speedtest is currently running"
        echo "  results      - View the most recent speedtest results"
        echo "  reboot       - Reboot the router"
        echo "  router-status - Show basic router status information"
        echo "  system-stats - Show detailed system statistics (CPU, temperature, memory)"
        echo ""
        echo "Usage:"
        echo "  http://70.70.70.1/cgi-bin/dashboard-control?action=start"
        echo "  http://70.70.70.1/cgi-bin/dashboard-control?action=status"
        echo "  http://70.70.70.1/cgi-bin/dashboard-control?action=results"
        echo "  http://70.70.70.1/cgi-bin/dashboard-control?action=reboot"
        echo "  http://70.70.70.1/cgi-bin/dashboard-control?action=router-status"
        echo "  http://70.70.70.1/cgi-bin/dashboard-control?action=system-stats"
        ;;
esac